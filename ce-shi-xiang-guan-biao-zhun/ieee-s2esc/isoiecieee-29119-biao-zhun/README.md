---
description: Software and systems engineering — Software testing
---

# ISO/IEC/IEEE 29119

## ISO/IEC/IEEE 29119相关标准说明

该系列标准主要是涉及软件静态和动态测试的标准，有如下子文档：

* ISO/IEC/IEEE 29119-1：PART 1: CONCEPTS AND DEFINITIONS
* ISO/IEC/IEEE 29119-2：PART 2: TEST PROCESSES
* ISO/IEC/IEEE 29119-3：PART 3: TEST DOCUMENTATION
* ISO/IEC/IEEE 29119-4：PART 4: TEST TECHNIQUES
* ISO/IEC/IEEE 29119-5：PART 5: KEYWORD-DRIVEN TESTING

## 标准内容概述

### 29119-1 概念与定义

软件测试的目标是在进度和成本约束下，尽早提供质量和遗留风险信息，尽可能发现多的缺陷来减轻产品质量差所带来的风险；

为了达成以上目标，采用了以下策略：

* 基于风险的测试，在有限的资源的情况下满足进度的要求；
* 基于需求的测试，提供质量相关的信息；
* 使用模型对被测对象进行建模和测试，尽可能的发现全部问题；

由于组织里面的活动往往是重复进行的，组织为了确保软件开发与测试更加高效，往往会固化流程，这个流程就叫做软件生命周期；软件生命周期分为开发和维护两个阶段；

为了在 这个组织里面有效的组织测试，达成上述策略，标准给出了三层测试模型：

* 组织测试管理 这个组织负责识别组织层面的风险，并给出通用的测试流程、方法和工具，确保大型组织测试活动的一致性；
* 项目测试管理 这个层面的管理者需要参照组织测试要求，根据项目的实际情况，在组织的风险的基础上识别项目和产品相关的风险；并在组织测试流程、方法和工具的基础上，进行裁剪和补充，形成项目相关的测试计划、策略；还要对测试过程进行监控，及时调整，对测试交付的结果负责；
* 具体测试设计

  这个层面需要根据项目的测试策略对被测对象进行测试分析和设计，实现和执行测试用例；

这里给出一个风险管理表格的示例：

![](../../../.gitbook/assets/image%20%28122%29.png)

### 29119-2 测试过程

本章中主要讲了三层软件测试模型中各个过程：

* 组织测试过程
  * 组织测试规范开发过程：用于开发组织测试政策与策略
* 测试管理过程
  * 测试计划过程：用于开发测试计划
  * 测试监控过程：用于监控计划的执行
  * 测试退出过程：用于测试退出
* 动态测试过程
  * 测试设计与实现过程：用于测试分析与设计，实现用例
  * 测试环节搭建过程：用于搭建测试环境
  * 测试执行过程：用于测试执行
  * 测试问题报告过程：用于测试中发现的缺陷报告、跟踪和关闭

所有过程都遵从Plan-Do-Check-Act的戴明环；

有两个过程是比较需要重点学习的：测试计划过程和测试设计与实现过程；

![](../../../.gitbook/assets/image%20%28143%29.png)

测试计划过程第一步是了解项目的上下文，说白了就是项目是什么项目、采用何种生命周期、项目的计划是怎么安排的等等；第二步，就是要确定谁参与测试计划的制订；第三步，就是要拉着大家一起对项目中的风险进行收集和统计，了解每个风险的大小，应对措施；第四步，就是对一些缺乏预防和应对措施的风险，安排测试活动；第五步，就是要确定谁来进行测试这测试活动；第六步，就是要把这些安排写在测试计划里面；第七步，就是对外发布；由于风险是随着项目的进行不断变化的，如，经过测试，发现风险比较小，或者比预期的更大，就需要不断进行调整，所以需要注意测试计划的刷新；

![](../../../.gitbook/assets/image%20%28144%29.png)

测试设计与实现过程第一步主要是识别被测对象的特性集，所谓特性集就是被测对象的质量属性；第二步，需要使用测试模型对这些特性进行建模；第三步，需要根据建出的模型，梳理测试覆盖项；第四步，需要编写测试用例去覆盖这些内容；第五步，需要把测试用例分好类，通常是按照测试目的、所需的测试环境来分；第六步，相当于测试建立好一个测试任务，把测试用例的执行顺序排好以便后续执行；

### 29119-3 测试文档

本章中主要讲了过程中涉及的各种测试文档；

测试文档主要有两个部分组成：

* 配置管理部分：文档的标识符，版本号，作者，状态，变更记录，审批人等等；
* 文档专有部分：文档的概述、文档特有的一些内容；

这里就不展开说了，具体看后续的笔记；

### 29119-4 测试设计技术

主要讲了静态和动态设计技术，特别是动态设计技术；

测试设计主要分为几个步骤：建模， 梳理模型中要覆盖的项目，编写用例覆盖；

根据建模的方式，分为黑盒、白盒、基于经验三种；

#### 黑盒测试

黑盒方式建模主要分为：

* 输入输出模型：等价类、边界值、语法、分类树、判定表、因果图、组合测试；
* 序列模型：场景测试；
* 状态模型：状态迁移测试；

**1.输入输出模型**

输入输出模型，即使用Input-Process-Output模型对系统进行建模；

![input-process-output](../../../.gitbook/assets/image%20%28129%29.png)

输入和输出之间的关系体现系统行为：

$$
output = f(input)
$$

即，系统的行为是输入和输出之间的映射函数；

输入和输出参数经常会出现无限取值的情况，为了解决这个问题，常常对输入和输出采用等价划分减少输入和输出域；

等价划分要求每个划分下的系统行为是类似的；因此，等价类的划分实际上暗含了处理行为类似的假设，在划分等价类的时候要特别注意；建议对无穷的输入参数进行归类来划分等价类，这样不容易漏测；

有些特殊的形式化描述的输入或者可以进行形式化描述的输入，也可以划分成等价类，具体的划分方法在语法测试中进行了介绍；

如，某个匹配规则，存在上行、下行两种类型的配置，而且可以同时配置上下行的匹配规则，用形式化的方式可以描述为： input = \(upConfig \| downConfig\) { 0, 8 }，使用语法测试设计方法，先展开里面的选择类型为 upConfig, downConfig, upConfig & downConfig；再展开里面的迭代类型为: 无配置，8条upConfig， 8条downConfig，8条upConfig与downConfig的混合配置， 9条upConfig， 9条downConfig，9条pConfig与downConfig的混合配置；

![Equivalence Partition](../../../.gitbook/assets/image%20%28128%29.png)

由于每个划分的边界值的处理很容易出现问题，所以往往对每个划分再应用边界值的分析设计方法；边界值设计主要有取2值法和取3值法，取2值法会取边界值和边界外部的值，取3值法会取边界内外的两个值和边界值；

![Boundary Equivalence Partition](../../../.gitbook/assets/image%20%28118%29.png)

由于输入和输出参数往往不止一个，因此IPO模型可以表述为：

$$
(output1,output2, ..., outputN) = f(input1, input2, ..., inputM)
$$

这样的函数；

为了解决多个参数的问题，引入了分类树；分类树把多个参数分成一个个分类，再把每个参数的取值分为一个个类型，再梳理输入和输出之间的关系；除了分类图外，还可以使用判定表和因果图来对这种多参数情况进行建模；

![classification tree](../../../.gitbook/assets/image%20%28113%29.png)



由于组合排列特别多，因此引入了组合测试设计的方法来减少要覆盖这些组合的测试用例；

根据美国国家技术域标准研究所的研究，n-wise排列，n要取值到6基本能发现所有的缺陷，特别是航空电子软件，涉及生命安全，特别强调这种严谨的方法进行测试：

![NIST&#x5173;&#x4E8E;&#x7EC4;&#x5408;&#x6D4B;&#x8BD5;&#x8BBE;&#x8BA1;&#x7684;&#x7814;&#x7A76;](../../../.gitbook/assets/image%20%28130%29.png)

#### 2. 序列模型

输入输出模型，把被测对象看作一个整体，考虑整体的输入和输出；

现实中的系统更加复杂，特别是和外部系统交互的适合，涉及到外部系统对被测系统的一系列操作；

这个时候再使用IPO模型对被测系统建模就不太合适，一般使用序列模型对操作顺序建模；

操作序列模型说白了就是把一个个的IPO模型串起来，使用序列的方式进行建模；

![&#x5E8F;&#x5217;&#x6A21;&#x578B;&#x793A;&#x610F;](../../../.gitbook/assets/image%20%28121%29.png)

操作序列模型的优点在于，一次操作可以覆盖多个功能模块，能模拟和外部系统\(比如用户\)的交互，容易发现多个模块和外部系统交互时产生的问题；； 

在进行测试覆盖时，往往一次覆盖一个完整的有意义的用户交互，因此序列模型往往也叫做场景测试；

#### 3. 状态模型

有时候系统对用户输入的处理往往和上个处理相关，即和状态相关，此时，使用IPO模型和序列模型均无法很好的对被测对象进行表示，这个时候就需要使用状态机对被测对象进行建模；

![](../../../.gitbook/assets/image%20%28123%29.png)

状态机模型中可以覆盖状态、也可以覆盖状态迁移，具体覆盖什么取决于测试策略；

#### 白盒测试

白盒测试的主要目的是验证程序的功能是否正常实现；

白盒测试设计技术有:

* 语句覆盖
* 分支覆盖
* 判定覆盖、条件分支覆盖、修改条件分支覆盖
* 数量流覆盖

无论哪种，都是为了验证程序正确实现了相关功能；

可以想象一下，程序实现前画了流程图，而这个验证就是验证里面的各个流程是否如预期设计般正常运作；

实际项目中，一般使用代码覆盖率工具，检查语句覆盖率，从而指导单元测试；使用静态扫描工具，发现数据流覆盖中期望发现的变量的定义与使用问题；

#### 基于经验测试

基于经验测试主要分为错误猜测、探索性测试和Checklist检查表；

基于经验测试常用于需求一团糟的情况，由于缺乏明确的文档和手册，因此测试只能依赖经验进行；

标准里面只提及了错误猜测法，现实生活中Checklist我们是用的最多的；

### 29119-5 关键字驱动测试

关键字驱动的核心概念就是模块化，把传统测试用例中的步骤全部模块化，用业务领域的语言进行描述，做到具体设备的操作无关；通过这种方式，让用例高度模块化后，便于用例的维护和自动化用例的实现；

标准介绍了典型的两层关键字驱动架构：业务领域层和测试接口层：

![&#x5173;&#x952E;&#x5B57;&#x4E00;&#x822C;&#x81F3;&#x5C11;&#x5305;&#x542B;&#x4E24;&#x5C42;](../../../.gitbook/assets/image%20%28137%29.png)

给出了测试框架实现的参考架构，以及每个模块应具备的特性：

* 关键字驱动手工用例架构

![](../../../.gitbook/assets/image%20%28140%29.png)

* 关键字驱动自动化用例架构

![](../../../.gitbook/assets/image%20%28138%29.png)

在实际项目中，关键字驱动的实现从简单到复杂各有不同；

最简单的实现，可以直接在编写自动化用例的时候，参考关键字驱动测试设计的思想，对测试函数进行封装，很多测试框架都支持这种形式，如，pytest，junit等等；

复杂的实现有robotframework这种，使用GUI界面进行关键字的编辑和测试用例的编写的；

具体采用哪种方式，我个人觉得还是使用关键字驱动的模块化思想来写会更好，限制更少；

