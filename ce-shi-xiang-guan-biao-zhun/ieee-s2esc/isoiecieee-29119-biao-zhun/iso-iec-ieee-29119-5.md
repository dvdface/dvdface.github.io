---
description: >-
  Software and Systems Engineering — Software Testing — Part 5: Keyword-Driven
  Testing
---

# ISO/IEC/IEEE 29119-5

## 关键字驱动概述

### 关键字驱动概念

关键字驱动测试是一种测试用例的编写方法，无论是手工测试还是自动化，它均适用；它适用于任何测试级别和测试类型；

关键字驱动通过创建一套关键字，再使用这套关键字去编写和实现自动化测试用例，从而让编写人员无需知晓测试编程与工具相关的知识；

关键字驱动的终极目标就是提供一套基础的、无二义性的关键字，几乎所有用例均可使用该关键字来实现；

### 关键字的优点

* 歧义更少，更容易理解；
* 模块化，用例不受操作步骤变化的影响；

### 关键字的定义

关键字的定义分为两个部分：

* **底层** 底层负责描述关键字相关的操作步骤；
* **顶层** 顶层负责给关键字起一个名字，表示关键字对应的测试步骤，并且列出关键字相关的输入参数；

### 关键字与用例的关系

![](../../../.gitbook/assets/image%20%28117%29.png)

测试过程包含测试用例；

测试用例分为关键字驱动写法的测试用例和手工测试用例；

关键字驱动写法的测试用例操作步骤由关键字构成；关键字中包含一系列的操作步骤；

手工测试用例由一个个操作步骤构成；

使用代码实现关键字，使用自动化框架为关键字驱动写法的用例自动创建可执行测试脚本；

手工测试用例自动化则需要为一条条用例编写测试脚本；

### 关键字分层实现

关键字驱动测试需要多层关键字来实现；

最高层的关键字通常是最抽象的，最底层的关键字是最详细的，一般与底层的GUI/CMD接口相对应；

![](../../../.gitbook/assets/image%20%28120%29.png)

* **Domain Layer**

  领域层对应业务和领域相关的活动，对应领域的一些专业术语；  
  有了领域层，测试人员可以在业务和领域内更加容易的编写测试用例；  
  领域层的关键字开发适合实现无关的，无需考虑实现被测对象的技术；  
  构建在领域层上面的测试不会受到被测对象实现的影响；

* **Test Interface Layer** 本层的关键字与具体的测试接口相关，它和被测对象的实现密切相关； 它的数量一般远少于领域层的关键字；一般把GUI控件、命令作为测试接口层的关键字； 在Test Interface Layer下面，可能还需要实现一层测试自动化层，来对被测接口\(GUI或CMD\)进行控制，如，WebDriver；

### 关键字类型

#### 简单关键字 vs 复合关键字

* **简单关键字** 简单关键字常用于Test Interface Layer； 根据被测对象的不同，一般由自动化框架提供一套预置的关键字来搞定；
* **复合关键字** 简单关键字虽然够用，但是它并不和功能特性相对应； 此时，需组合使用简单关键字实现更复杂的操作，参数可能会需要用到符合参数，即，数据结构； 适合复合关键字使得用例使用业务或域模型来表达成为了可能，有助于大家对业务的理解；

![&#x4F7F;&#x7528;&#x590D;&#x5408;&#x5173;&#x952E;&#x5B57;&#x6784;&#x5EFA;intermediate layer](../../../.gitbook/assets/image%20%28132%29.png)

* **导航/交互\(input\)关键字 vs 验证\(output\)关键字** 关键字一般可以分为导航输入类的关键字和验证的关键字； 验证关键字往往和测试用例的执行结果密切相关，因此往往让导航关键字实现验证功能； 有些验证类的导航关键字，仅用于某个导航关键字，那么就应该和这个导航关键字合二为一； 有些导航关键字有时候预期结果是成功，有时候预期结果是失败，这个时候需要有参数进行控制；

### 关键字和测试结果

关键字除了导航、验证，还可以用来判断测试状态、抓取测试结果，包括，但不限于：

* 测试输出
* 复合测试成功标准
* 测试执行日志
* 硬件输出
* 系统状态
* 测试失败
  * 测试输出与预期不一
  * 步骤无法执行

有些关键字在执行的时候可能会出现阻塞，此时需要对关键字进行标注，一般标注为：

* May be blocked
* Must not be blocked

前者不会影响测试结果，后者则会影响测试结果；

测试框架还可以提供额外的错误识别机制，处理关键字返回的错误信息；

### 关键字驱动和数据驱动测试

关键字可以带参数，参数的数量可以是固定长度的，也可以是可变长度的；

大部分关键字需要至少一个参数来指定需要操作的对象；某些还需要一个参数，指定输入的值；

对于复合关键字，由于其功能更加复杂，参数的数量会更加的多，测试数据会更加复杂；

实践上，一般将测试数据与测试步骤相分离；把测试数据独立存储\(表格、表单、数据库中存储\)，在关键字中对测试数据进行引用；

这种方式催生了Data-Driven Testing方法，它不同于Keyword-Driven Testing；

## 关键字驱动测试实践

### 识别关键字

关键字驱动测试中首要的任务是识别关键字；

关键字的粒度和结构会影响基于关键字用例的编写；

关键字的命名务必要便于编写用例人的理解；

当识别关键字时，需要进行以下步骤：

1. 识别需要哪些层关键字，定义每层所需关键字类型；
2. 基于每层关键字的范围和定义，识别对应的关键字： 把一组相关的操作序列归为一个关键字，并命名，并将其中所涉及的参数作为关键字参数； 基础关键字可通过观察在测试接口层会进行哪些操作来识别，如，键盘、鼠标、触摸屏、麦克风等； 复合关键字则是观察用户会进行哪些常用的、重复的操作来识别，一般把一些典型的业务行为封装为复合关键字，如，创建用户；

一般使用以下信息对关键字进行描述：

1. 关键字的名字
2. 关键字相关参数
3. 关键字文档信息
   * 所属层次；
   * 关键字类型：Navigation类型还是Verify类型； 
   * 使用的上下文；
   * 关键字所涉及的操作：可以是操作的描述、对底层关键字的引用；
   * 关键字目标；
4. 所用关键字清单：如果是复合关键字，需要列清楚所用的底层关键字清单；

关键字一般有如下质量要求：

1. 唯一性：在上下文中，每个关键字都是唯一的；
2. 可重用：每个关键字都可以被重用；
3. 完备性：关键字的定义应考虑到所有已知的元素和测试接口的可能的交互作用；
4. 清晰性：定义关键字时，应当保持结构的一致性；
5. 特异性：每个关键字不重复；

### 编写用例

编写用例时，一般只是用某一层的关键字；如，要么用领域层的，要么用测试接口层的；

#### 数据驱动测试

当很多测试用例步骤相同，只是参数不同时，可以将其改造为数据驱动测试的用例；

### 维护关键字

关键字驱动测试也需要维护，随着关键字不断的创建，用例不断的增改会慢慢出现如下问题：

* 冗余关键字：存在两个或者多个用途一样的关键字；
* 无用关键字；
* 关键字变更导致的冲突：修复一个用例，却导致其他的用例出现问题；
* 关键字不当修改：导致返工、用例失效；

为了解决这些问题，需要做如下维护动作：

* 关键字驱动框架提供关键字交叉引用的功能，以便能找出受到关键字修改影响的相关用例；
* 成立一个关键字维护组织，对关键字进行维护\(审核关键字的新增与修改\)；
* 针对关键字开发和维护，定期进行开会沟通；
* 制定清晰的结构对关键字进行管理，可以按层、按被测对象、被测对象的某各区域对关键字进行分组管理等等；
* 用配置管理对关键字进行管理；

### 测试设计中的应用

![](../../../.gitbook/assets/image%20%28134%29.png)

TD4流程中有四个环节：

1. 确定预置条件
2. 选择输入参数
3. 选择测试步骤
4. 确定预期结果

这四个环节中均可以采用关键字驱动的方式进行设计、特别是步骤3，因为涉及到多个参数，还可以采用数据驱动测试的方式设计；

### 改造已有用例

可以使用关键字驱动的方式来改造现有测试用例；

不过，如果用例规模大，已经实现了自动化，一般不动；

## 关键字驱动测试框架

### 概述

只描述应该实现什么，而不描述如何实现；

### 整体架构

#### **手工用例架构**

\*\*\*\*

![](../../../.gitbook/assets/image%20%28136%29.png)

#### **自动化用例架构**

![](../../../.gitbook/assets/image%20%28135%29.png)



* **Editor** 关键字驱动用例编写器；
* **Decomposer** 它负责把包含复合关键字用例转换成基础关键字用例；
* **Data Sequencer** 负责将用例中的测试数据占位符替换为对应的测试数据；
* **Manual Test Assistant**

  负责呈现测试用例执行界面，方便测试人员执行测试用例，打结果；  
  一般由测试管理工具实现；

* **Tool Bridge** 负责根据关键字驱动用例调用执行引擎创建可执行脚本；
* **Test Execution Environment & Execution Engine** 执行引擎执行关键字相关的动作实现测试用例的执行；
* **Keyword Library** 关键字库负责存储关键字； 基础关键字会存储名称、描述、参数； 复合关键字还需要存储其相关的基础关键字清单； 如果要实现自动化，关键字还得存储相关的脚本； 一般由测试管理工具实现；
* **Data** 这个地方负责存储测试用例中所用到的数据； 关键字驱动的用例可以直接把测试数据写在用例中，也可以只写占位符，另存相关数据，这种情况需要用到Data组件； 一般会把数据单独存在一个数据文件中，或者存在测试管理工具中，执行时由Data Sequencer进行处理；
* **Script Repository** 脚本仓库一般负责存放关键字脚本；

### 必备特性

* 有相关文档描述关键字、关键字参数、参数默认值
* 有相关文档描述关键字分层，以及各层关键字；
* 有相关文档描述数据驱动测试中的数据存储方式，以及如何引用；
* 专用测试用例编辑器
  * 非复合类型的关键字，需要显示相关的操作步骤；
  * 关键字编辑器应支持直接访问关键字的定义；
  * 关键字编辑器允许使用带参数的关键字实现数据驱动测试；
  * 关键字编辑器应当支持注释；
  * 关键字编辑器应当提供测试数据的引用功能；
  * 关键字编辑器里面对关键字的使用都应该是引用的方式，而非拷贝的方式；
  * 关键字编辑器应支持定义测试用例执行顺序；
* 分解器和数据序列器
  * 分解器负责处理关键字，可以将组合关键字分解为基础关键字；
  * 数据序列器负责处理关键字参数，负责把数据驱动的用例转换为普通关键字用例；
* 手工用例执行工具
  * 手工用例执行工具应支持手工用例执行；
  * 手工用例执行工具应支持将测试失败与相关缺陷关联起来；
* 工具桥
  * 工具桥负责提供执行引擎，来执行测试用例；
* 测试执行引擎
  * 非条件或者循环下的关键字，应该顺序执行；
  * 执行引擎应可识别未实现的关键字；
  * 执行引擎应支持关键字变量为直接数值型和变量引用型；
  * 执行引擎应提供每个关键字的执行结果；
  * 执行引擎应支持存储执行的时间戳；
  * 执行引擎应支持错误导致的阻塞；
  * 执行引擎应支持PASS/FAIL；
  * 执行引擎在执行日志中应包含执行的唯一标识符；
  * 执行引擎在执行日志中应包含执行环境的唯一标识符；
  * 执行引擎在执行日志中应包含被测对象的唯一标识符；
  * 执行引擎应该提供一种机制在多应用关键字之间进行选择；
  * 执行引擎应该可向测试用户反馈执行结果；
* 关键字库
  * 支持定义关键字，包括名字、描述和参数；
* 脚本仓库
  * 仓库可存储关键字代码；
  * 仓库应支持引用其他关键字库；

### 高级特性

* 有相关文档描述关键字编写用例的规则；
* 有相关文档描述参数描述的规则；
* 有相关文档描述传参规则；
* 有相关文档描述关键字定义规则；
* 专用测试用例编辑器
  * 用例编辑器应能检查测试用例的语法；
  * 用例编辑器应能找出哪些用例使用了某个关键字；
  * 用例编辑器应能检查测试用例使用的关键字是经过定义的；
  * 用例编辑器应能突出显示未定义的关键字；
  * 用例编辑器应支持异常处理，即，出错后可以执行清理动作；
  * 用例编辑器应支持自动补全和DnD；
  * 用例编辑器应支持对关键字驱动的用例进行版本管理；
* 分解器和数据序列器
  * 分解器和数据序列器应支持实现新的关键字；
  * 分解器和数据序列器应支持层次的结构化的数据定义；
* 手工用例执行工具
  * 用例执行工具应支持往日志里面增加截图和其他输出；
* 工具桥
* 测试执行环境和执行引擎
  * 执行引擎应该可以读取、存储和处理被测对象的数据；
  * 执行引擎应支持变量的命名空间；
  * 执行引擎应支持多个用例之间的上下文切换；
  * 执行引擎应支持在不同命名空间之间切换；
  * 执行引擎应支持同时对数据进行并发访问；
  * 执行引擎应支持处理阻塞的关键字；
  * 执行引擎应支持数据驱动测试；
  * 执行引擎应支持条件语句；
  * 执行引擎应支持应用级别的配置文件；
  * 执行引擎应支持至少一个配置；
  * 执行引擎应支持异常处理；
  * 执行引擎中关键字执行代码应能分配相关信息，完成相关要求；
  * 执行引擎应该根据关键字名称，参数匹配对应的执行脚本；
  * 执行引擎应能阻止无限循环的同时，支持有限时间或者次数的循环；
* 关键字库
  * 字库应该支持基于基础字库构造关键字；
  * 字库应该支持关键字库的版本管理；
  * 字库应该支持别称，缩略语和国际化；
* 测试数据支持
  * 框架应支持测试数据版本管理
  * 框架应允许定义结构化的数据类型；
* 脚本仓库
  * 支持关键字库脚本版本管理





