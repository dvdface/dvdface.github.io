---
description: Software and systems engineering — Software testing
---

# ISO/IEC/IEEE 29119

## ISO/IEC/IEEE 29119相关标准说明

该系列标准主要是涉及软件静态和动态测试的标准，有如下子文档：

* ISO/IEC/IEEE 29119-1：PART 1: CONCEPTS AND DEFINITIONS
* ISO/IEC/IEEE 29119-2：PART 2: TEST PROCESSES
* ISO/IEC/IEEE 29119-3：PART 3: TEST DOCUMENTATION
* ISO/IEC/IEEE 29119-4：PART 4: TEST TECHNIQUES
* ISO/IEC/IEEE 29119-5：PART 5: KEYWORD-DRIVEN TESTING

## 标准内容概述

### 29119-1 概念与定义

软件测试的目标是在进度和成本约束下，尽早提供质量和遗留风险信息，尽可能发现多的缺陷来减轻产品质量差所带来的风险；

为了达成以上目标，采用了以下策略：

* 基于风险的测试，在有限的资源的情况下满足进度的要求；
* 基于需求的测试，提供质量相关的信息；
* 使用模型对被测对象进行建模和测试，尽可能的发现全部问题；

由于组织里面的活动往往是重复进行的，组织为了确保软件开发与测试更加高效，往往会固化流程，这个流程就叫做软件生命周期；软件生命周期分为开发和维护两个阶段；

为了在 这个组织里面有效的组织测试，达成上述策略，标准给出了三层测试模型：

* 组织测试管理 这个组织负责识别组织层面的风险，并给出通用的测试流程、方法和工具，确保大型组织测试活动的一致性；
* 项目测试管理 这个层面的管理者需要参照组织测试要求，根据项目的实际情况，在组织的风险的基础上识别项目和产品相关的风险；并在组织测试流程、方法和工具的基础上，进行裁剪和补充，形成项目相关的测试计划、策略；还要对测试过程进行监控，及时调整，对测试交付的结果负责；
* 具体测试设计

  这个层面需要根据项目的测试策略对被测对象进行测试分析和设计，实现和执行测试用例；

这里给出一个风险管理表格的示例：

![](../../../.gitbook/assets/image%20%28122%29.png)

### 29119-2 测试过程

本章中主要讲了三层软件测试模型中各个过程：

* 组织测试过程
  * 组织测试规范开发过程：用于开发组织测试政策与策略
* 测试管理过程
  * 测试计划过程：用于开发测试计划
  * 测试监控过程：用于监控计划的执行
  * 测试退出过程：用于测试退出
* 动态测试过程
  * 测试设计与实现过程：用于测试分析与设计，实现用例
  * 测试环节搭建过程：用于搭建测试环境
  * 测试执行过程：用于测试执行
  * 测试问题报告过程：用于测试中发现的缺陷报告、跟踪和关闭

所有过程都遵从Plan-Do-Check-Act的戴明环；

有两个过程是比较需要重点学习的：测试计划过程和测试设计与实现过程；

测试计划过程第一步是了解项目的上下文，说白了就是项目是什么项目、采用何种生命周期、项目的计划是怎么安排的等等；第二步，就是要确定谁参与测试计划的制订；第三步，就是要拉着大家一起对项目中的风险进行收集和统计，了解每个风险的大小，应对措施；第四步，就是对一些缺乏预防和应对措施的风险，安排测试活动；第五步，就是要确定谁来进行测试这测试活动；第六步，就是要把这些安排写在测试计划里面；第七步，就是对外发布；由于风险是随着项目的进行不断变化的，如，经过测试，发现风险比较小，或者比预期的更大，就需要不断进行调整，所以需要注意测试计划的刷新；

测试设计与实现过程第一步主要是识别被测对象的特性集，所谓特性集就是被测对象的质量属性；第二步，需要使用测试模型对这些特性进行建模；第三步，需要根据建出的模型，梳理测试覆盖项；第四步，需要编写测试用例去覆盖这些内容；第五步，需要把测试用例分好类，通常是按照测试目的、所需的测试环境来分；第六步，相当于测试建立好一个测试任务，把测试用例的执行顺序排好以便后续执行；

### 29119-3 测试文档

本章中主要讲了过程中涉及的各种测试文档；

测试文档主要有两个部分组成：

* 配置管理部分：文档的标识符，版本号，作者，状态，变更记录，审批人等等；
* 文档专有部分：文档的概述、文档特有的一些内容；

这里就不展开说了，具体看后续的笔记；

### 29119-4 测试设计技术

主要讲了静态和动态设计技术，特别是动态设计技术；

测试设计主要分为几个步骤：建模， 梳理模型中要覆盖的项目，编写用例覆盖；

根据建模的方式，分为黑盒、白盒、基于经验三种；

黑盒方式建模主要分为：

* 输入输出模型：等价类、边界值、语法、分类树、判定表、因果图、组合测试；
* 序列模型：场景测试；
* 状态模型：状态迁移测试；

#### **输入输出模型**

输入输出模型，即使用Input-Process-Output模型对系统进行建模；

![input-process-output](../../../.gitbook/assets/image%20%28129%29.png)

输入和输出之间的关系体现系统行为：

$$
output = f(input)
$$

即，系统的行为是输入和输出之间的映射函数；

输入和输出参数经常会出现无限取值的情况，为了解决这个问题，常常对输入和输出采用等价划分减少输入和输出域；

等价划分要求每个划分下的系统行为是类似的；因此，等价类的划分实际上暗含了处理行为类似的假设，在划分等价类的时候要特别注意；

有些特殊的形式化描述的输入，也可以划分成等价类，具体的划分方法在语法测试中进行了介绍；

![Equivalence Partition](../../../.gitbook/assets/image%20%28128%29.png)

由于每个划分的边界值的处理很容易出现问题，所以往往对每个划分再应用边界值的分析设计方法；边界值设计主要有取2值法和取3值法，取2值法会取边界值和边界外部的值，取3值法会取边界内外的两个值和边界值；

![Boundary Equivalence Partition](../../../.gitbook/assets/image%20%28118%29.png)

由于输入和输出参数往往不止一个，因此IPO模型可以表述为：

$$
(output1,output2, ..., outputN) = f(input1, input2, ..., inputM)
$$

这样的函数；

为了解决多个参数的问题，引入了分类树；分类树把多个参数分成一个个分类，再把每个参数的取值分为一个个类型，再梳理输入和输出之间的关系；除了分类图外，还可以使用判定表和因果图来对这种多参数情况进行建模；

![classification tree](../../../.gitbook/assets/image%20%28113%29.png)



由于组合排列特别多，因此引入了组合测试设计的方法来减少要覆盖这些组合的测试用例；

根据美国国家技术域标准研究所的研究，n-wise排列，n要取值到6基本能发现所有的缺陷，特别是航空电子软件，涉及生命安全，特别强调这种严谨的方法进行测试：

![NIST&#x5173;&#x4E8E;&#x7EC4;&#x5408;&#x6D4B;&#x8BD5;&#x8BBE;&#x8BA1;&#x7684;&#x7814;&#x7A76;](../../../.gitbook/assets/image%20%28130%29.png)

#### 序列模型

输入输出模型，把被测对象看作一个整体，考虑整体的输入和输出；

现实中的系统更加复杂，特别是和外部系统交互的适合，涉及到外部系统对被测系统的一系列操作；

这个时候再使用IPO模型对被测系统建模就不太合适，此时需要采用操作序列模型；

操作序列模型说白了就是把一个个的IPO模型串起来，使用序列的方式进行建模；

![&#x5E8F;&#x5217;&#x6A21;&#x578B;&#x793A;&#x610F;](../../../.gitbook/assets/image%20%28121%29.png)

操作序列模型的优点在于，一次操作可以覆盖多个功能模块，能模拟和外部系统\(比如用户\)的交互，容易发现多个模块和外部系统交互时产生的问题；；

在进行测试覆盖时，往往一次覆盖一个完整的有意义的用户交互，因此序列模型往往也叫做场景测试；

#### 状态模型

有时候系统对用户输入的处理往往和上个处理相关，即和状态相关，此时，使用IPO模型和序列模型均无法很好的对被测对象进行表示，这个时候就需要使用状态机对被测对象进行建模；

![](../../../.gitbook/assets/image%20%28123%29.png)

状态机模型中可以覆盖状态、也可以覆盖状态迁移，具体覆盖什么取决于测试策略；



