---
description: Software and systems engineering — Software testing
---

# ISO/IEC/IEEE 29119

## ISO/IEC/IEEE 29119相关标准说明

该系列标准主要是涉及软件静态和动态测试的标准，有如下子文档：

* ISO/IEC/IEEE 29119-1：PART 1: CONCEPTS AND DEFINITIONS
* ISO/IEC/IEEE 29119-2：PART 2: TEST PROCESSES
* ISO/IEC/IEEE 29119-3：PART 3: TEST DOCUMENTATION
* ISO/IEC/IEEE 29119-4：PART 4: TEST TECHNIQUES
* ISO/IEC/IEEE 29119-5：PART 5: KEYWORD-DRIVEN TESTING
* ISO/IEC TR 29119-6：PART 6: GUIDELINES FOR THE USE OF ISO/IEC/IEEE 29119 \(ALL PARTS\) IN AGILE PROJECTS 

## 标准内容概述

### 29119-1 概念与定义

软件测试的目标：在进度和成本约束下，尽早提供质量和遗留风险信息，尽可能发现多的缺陷来减轻产品质量差所带来的风险；

* 达成软件测试目标的策略：
  * 进度约束的达成策略是采取测试管理措施；
  * 成本约束的达成策略是采取基于风险的测试实践；
  * 提供质量信息的达成策略是在测试计划与实现时采取基于需求的测试实践；
  * 提供遗留风险信息的达成策略采取的是使用风险更新和缺陷报告机制；
  * 尽可能发现多的缺陷的达成策略是测试计划与实现时采取基于模型的测试实践；
* 介绍了软件生命周期
  * 定义软件生命周期的目的：让软件产品开发过程变更高效、且重复进行；
  * 两个阶段：开发阶段和维护阶段；
* 概述了三层测试模型：
  * 为什么需要使用三层测试模型：
    * 最高级别的组织管理
      * 大型组织为了保证测试的一致性，需要高层组织进行协调和管理；
    * 软件测试管理：计划、监控和控制、完成
      * 软件测试受到各种约束，需要测试计划主要根据风险平衡资源与测试需求；
      * 组织级别制定的通用策略不可能放之四海而皆准，需裁剪完善，因此需要测试管理；
    * 测试子过程
      * 测试计划中分析所得到的测试策略需要测试子过程去实现；
      * 无论是不同的Test Level还是不同的Test Type都依赖测试子过程去实现；
      * 测试子过程还可以包含其他测试子过程；
      * 测试子过程类型分为静态和动态子过程，重点涉及动态子过程；
  * 三层测试过程模型有哪些：
    * 组织测试过程：组织测试政策、组织测试策略；
    * 测试管理过程：测试计划、测试监控、测试完成；
    * 动态测试过程：测试设计与实现、测试环境搭建与维护、测试执行、测试问题报告；
  * 对测试子过程进行了详述：
    * 项目测试计划主要讲测试的目标和达成的手段，手段就是通过各个子测试过程完成；
    * 测试子过程可以包含其他测试子过程，此时它由两个部分组成：测试目标，子过程清单；
    * 不包含其他子过程的测试子过程描述由四个部分组成：测试目标、被测对象、静态/动态测试过程详述和采用的测试设计技术；
    * 列举了典型的测试目标：
      * 为风险管理活动提供信息；
      * 提供产品质量信息；
      * 评估产品质量是否满足干系人预期；
      * 评估缺陷是否修复；
      * 评估需求是否满足；
    * 定义并列举了典型的被测对象：活动产物均可作为被测对象
      * 代码相关的被测对象：可执行程序、子系统、完整系统
      * 文档相关的被测对象：计划、需求规格、架构设计、详细设计、源码、手册、测试文档
    * 列举了典型的测试依据：依据可来自软件生命周期的各个阶段，需求、文档、代码、预期、经验等
    * 详细的测试过程：测试设计与实现、测试环节搭建与维护、测试执行、测试报告；
    * 说明采用的测试设计技术：静态测试和动态测试；
* 介绍了软件测试活动与其他支撑活动之间的联系：
  * 质量保证活动：
    * 质量保证活动强制性要求使用一些方法、标准、工具和技能来确保质量；
    * 它需要测试结果信息来调研在软件工程过程中各个阶段问题；
  * 项目管理活动：
    * 项目管理主要是负责对项目进行计划和管理，包括测试项目的管理；
    * 测试活动评估、风险分析、计划安排依赖于整体的项目计划；
    * 测试活动度量信息经测试经理分析后提供给项目经理，项目根据进度可能会变更项目计划；
    * 测试完成后，测试完成报告会提交给项目经理；
  * 配置管理活动：
    * 配置管理主要是建立和维护工作产品的完整性；
    * 配置管理涉及对配置项的标识、存储控制、发布审计、变更控制、状态报告；
    * 软件测试中很多工作产品需要进行配置管理：组织测试规范、测试计划、测试规格等；
  * 过程改进活动：
    * 过程改进活动主要是改变组织的流动，使其更高效；
    * 测试活动可以为过程改进活动提供分析所需的信息；
    * 测试活动本身可以作为过程改进的结果；
* 介绍了基于风险的测试如何在三层测试过程模型中展开：
  * 组织测试过程
    * 在组织测试政策中识别组织级别的风险；
    * 在组织测试策略中采取措施管理测试流程中的风险，并给出测试方法来应对这些风险；
  * 测试管理过程
    * 让人广泛地参与进来，尽可能识别风险并对风险达成一致，且了解它们所采取的应对措施；
    * 整理风险\(分类并评分\)，制定基于风险的测试计划；
      * 风险评分，决定测试力度\(独立的测试子过程、测试设计技术的选取、测试完成标准\)；
      * 风险优先级，决定测试优先级\(测试先执行，问题先处理\)；
      * 风险类型，决定测试类型\(组件交互接口的风险用集成测试，难用的风险用易用性测试\)；
    * 对已知风险进行测试以及业务的变化都会导致风险变化，因此还需要不断更新风险跟踪表；
  * 动态测试过程
    * 动态测试过程是一种风险缓解活动：测试通过风险发生可能性低；不过发生风险可能性高；
    * 测试设计活动中，产品风险\(质量风险\)可以帮助测试人员确定应用哪种测试设计技术；
    * 测试设计活动中，风险的大小可以帮助测试人员确定测试分析的多寡；
    * 风险还用于为特性、测试规格、测试用例确定优先级；

### 29119-2 测试过程

本章中主要讲了三层软件测试模型中各个过程：

* 组织测试过程
  * 组织测试规范开发过程
* 测试管理过程
  * 测试计划过程
  * 测试监控过程
  * 测试退出过程
* 动态测试过程
  * 测试设计与实现过程
  * 测试环节搭建过程
  * 测试执行过程
  * 测试问题报告过程

所有过程都遵从Plan-Do-Check-Act的戴明环；

有两个过程是比较需要特别关注的：

* 测试计划过程：
  1. 理解上下文：搞清楚测什么，怎么测，什么时候测，谁来测；
  2. 组织测试计划开发：项目经理、测试经理等需要参与
  3. 识别和分析风险：收集进度风险\(项目风险\)和质量风险\(产品风险\)，分门别类；
  4. 确定风险缓解措施：确定风险应对措施，测试就是应对风险的一种；
  5. 设计测试策略：根据需要进行的测试风险应对措施，编制测试子计划、子过程列表；
  6. 确定人员和计划：确定这些活谁来做；
  7. 编写测试计划：安排下去写测试计划、测试子过程；
  8. 对测试计划沟通达成一致：沟通，达成一致；
  9. 发布测试计划 ：让大家都知道
* 测试设计与实现过程
  1. 创建特性集合：分析依据，得到特性集，做追溯，特性集合一般与架构相对应；

     特性集合就是能与其他特性相互区分的被测特性；

  2. 推导测试规格：应用测试设计技术，得出测试规格；

     测试规格就是被测对象的一个质量属性的一个方面，如，XX功能、XX性能等等；

  3. 推导测试覆盖项：应用测试设计技术，得出测试覆盖项； 覆盖测试项目就是规格模型里面的测试子项；
  4. 推导测试用例：应用测试设计技术，得出用例；
  5. 创建测试集合：根据用例执行约束，为用例分组；
  6. 创建测试过程：把用例排好执行优先级，得到测试过程；

### 29119-3 测试文档

本章中主要讲了过程中涉及的各种测试文档；

测试文档主要有两个部分组成：

* 配置管理部分：文档的标识符，版本号，作者，状态，变更记录，审批人等等；
* 文档专有部分：文档的概述、文档特有的一些内容；

### 29119-4 测试设计技术

主要讲了静态和动态设计技术，特别是动态设计技术；

测试设计主要分为几个步骤：建模， 梳理模型中要覆盖的项目，编写用例覆盖；

根据建模的方式，分为黑盒、白盒、基于经验三种；

黑盒方式建模主要分为：

* 输入输出模型：等价类、边界值、分类树、判定表、组合测试；
* 序列模型：场景测试；
* 迁移模型：状态迁移测试；

#### **输入输出模型**

输入输出模型，即使用Input-Process-Output模型对系统进行建模；

![Input-Process-Output Model ](../../../.gitbook/assets/image%20%28117%29.png)

输入和输出之间的关系体现系统行为：

$$
output = f(input)
$$

即，系统的行为是输入和输出之间的映射函数；

输入和输出参数经常会出现无限取值的情况，为了解决这个问题，常常对输入和输出采用等价划分减少输入和输出域；等价划分要求每个划分下的系统行为是类似的；

由于每个划分的边界值的处理很容易出现问题，所以往往对每个划分再应用边界值的分析设计方法；边界值设计主要有取2值法和取3值法，取2值法会取边界值和边界外部的值，取3值法会取边界内外的两个值和边界值；

由于输入和输出参数往往不止一个，因此IPO模型可以表述为：

$$
(output1,output2, ..., outputN) = f(input1, input2, ..., inputM)
$$

这样的函数；

引入了分类树的方式；分类树把多个参数分成一个个分类，再把每个参数的取值分为一个个类型，再使用测试用例来覆盖它们之间的组合关系；

![&#x5206;&#x7C7B;&#x6811;&#x793A;&#x610F;&#x56FE;](../../../.gitbook/assets/image%20%28113%29.png)

由于组合排列特别多，因此引入了组合测试设计的方法来减少测试组合；根据美国国家技术域标准研究所的研究，n-wise排列，n要取值到6基本能发现所有的缺陷，特别是航空电子软件，涉及生命安全，特别强调这种严谨的方法进行测试：

![NIST&#x5173;&#x4E8E;&#x7EC4;&#x5408;&#x6D4B;&#x8BD5;&#x8BBE;&#x8BA1;&#x7684;&#x7814;&#x7A76;](../../../.gitbook/assets/image%20%28120%29.png)

#### 序列模型

输入输出模型，把被测对象看作一个整体，考虑整体的输入和输出；

现实中的系统更加复杂，特别是和外部系统交互的适合，涉及到外部系统对他的一系列操作；

这个适合再使用IPO模型对被测系统建模就不太合适，此时需要采用操作序列模型；

操作序列模型的优点在于，一次操作可以覆盖多个功能模块，能模拟和外部系统的交互，容易发现和外部系统交互时产生的问题；

![](../../../.gitbook/assets/image%20%28118%29.png)





